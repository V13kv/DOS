Turbo Assembler	 Version 4.1	    02/21/22 02:35:39	    Page 1
shell.asm



      1	0000			     .model tiny
      2				     .186
      3	0000			     .code
      4				     org 100h
      5
      6	      =0024		     prompt_end	     equ     "$"
      7
      8	0100			     _start:
      9	0100  BC 04F4 90		     mov sp, 100h + length_of_program +	200h ; Move stack by 200h after
     10										     ; program end (additional 100h
     11										     ; for PSP)
     12
     13					     ; TODO: Use mask to determine what	to add
     14	0104  B4 4A			     mov ah, 4Ah
     15	      =04F4			     stack_shift = 100h	+ length_of_program + 200h
     16	0106  BB 0050			     mov bx, (stack_shift shr 4) + 1
     17	0109  CD 21			     int 21h
     18
     19					     ; Fill EPB	(Execution Program Block) containing segment addresses
     20	010B  8C C8			     mov ax, cs
     21	010D  A3 01EEr			     mov word ptr EPB+4, ax		     ; Command prompt segment address
     22	0110  A3 01F2r			     mov word ptr EPB+8, ax		     ; First FCB (1st cmd parameter) segment address
     23	0113  A3 01F6r			     mov word ptr EPB+0Ch, ax		     ; Second FCB (2nd cmd parameter) segment address
     24
     25	0116			     main_loop:
     26					     ; Getting drive letter (as	a char)
     27	0116  B4 19			     mov ah, 19h
     28	0118  CD 21			     int 21h
     29	011A  04 41			     add al, 'A'
     30	011C  A2 0199r			     mov [drive_letter], al
     31
     32					     ; Get current working directory (default directory	<=> path)
     33	011F  B4 47			     mov ah, 47h
     34	0121  B2 00			     mov dl, 00
     35	0123  BE 019Br			     mov si, offset pwd_buffer	     ; place current path to pwd_buffer	(64 bytes)
     36	0126  CD 21			     int 21h
     37
     38					     ; Get the pointer to the null byte	(end of	the my command prompt)
     39	0128  B0 00			     mov al, 0
     40	012A  BF 018Fr			     mov di, offset prompt_start
     41	012D  B9 004C 90		     mov cx, prompt_l
     42	0131  F2> AE			     repne scasb
     43	0133  4F			     dec di
     44
     45	0134  B0 24			     mov al, prompt_end
     46	0136  88 05			     mov [di], al
     47	0138  47			     inc di
     48
     49					     ; Get length of my	command	prompt
     50	0139  BA 018Fr			     mov dx, offset prompt_start
     51	013C  2B FA			     sub di, dx
     52
     53					     ; Output my command prompt	to stdout file
     54	013E  8B CF			     mov cx, di
     55	0140  BB 0001			     mov bx, 1
     56	0143  B4 40			     mov ah, 40h
     57	0145  CD 21			     int 21h
Turbo Assembler	 Version 4.1	    02/21/22 02:35:39	    Page 2
shell.asm



     58
     59					     ; Output prompt end symbol	to stdout file
     60				     ;	     mov al, prompt_end
     61				     ;	     int 29h
     62
     63				     ; GET && PROCESS USER INPUT CODE
     64					     ; Get user	input
     65	0147  B4 0A			     mov ah, 0Ah
     66	0149  BA 0277r			     mov dx, offset command_buffer   ; buffer contains input terminated	with CR	(0Dh)
     67	014C  CD 21			     int 21h
     68
     69					     ; Set cursor to start of the line (outputs	al character (0Dh <=> \r))
     70	014E  B0 0D			     mov al, 0Dh
     71	0150  CD 29			     int 29h
     72
     73					     ; Set cursor to next line (outputs	al char	(0Ah (LF - Line	Feed <=> \n (scroll if	    +
     74				     needed))
     75	0152  B0 0A			     mov al, 0Ah
     76	0154  CD 29			     int 29h
     77
     78					     ; Check if	user has typed non-zero	length string (command)
     79	0156  80 3E 0278r 00		     cmp byte ptr command_buffer+1, 0	     ; command_buffer +	1 store	actual length of    +
     80				     input (not	counting END 0Dh (CR) symbol)
     81	015B  74 B9			     je	main_loop
     82
     83					     ; Check input for 'exit' command
     84	015D  BF 0279r			     mov di, offset command_buffer+2
     85	0160  BE 018Ar			     mov si, offset cmd_exit
     86	0163  B9 0005 90		     mov cx, cmd_exit_l
     87	0167  F3> A6			     repe cmpsb
     88	0169  E3 1D			     jcxz got_exit			     ; If it is	an 'exit' command then exit
     89
     90
     91					     ; Copy inputed command to allocated command_text buffer
     92	016B  33 C9			     xor cx, cx
     93	016D  BE 0279r			     mov si, offset command_buffer+2
     94	0170  BF 01FDr			     mov di, offset command_text
     95
     96					     ; 2 bottom	lines are computing inputed command length (including 0Dh (CR) symbol)
     97	0173  8A 0E 0278r		     mov cl, byte ptr command_buffer+1
     98	0177  FE C1			     inc cl
     99	0179  F3> A4			     rep movsb				     ; copy
    100
    101					     ; Call && Execute 'command.com' with the inputed command
    102	017B  B8 4B00			     mov ax, 4B00h
    103	017E  BA 01DBr			     mov dx, offset command_com
    104	0181  BB 01EAr			     mov bx, offset EPB
    105	0184  CD 21			     int 21h
    106
    107	0186  EB 8E			     jmp short main_loop
    108
    109	0188			     got_exit:
    110	0188  CD 20			     int 20h
    111
    112				     ; My own commands that are	handled	by my own code
    113	018A  65 78 69 74 0D	     cmd_exit	     db	     "exit", 0Dh
    114	      =0005		     cmd_exit_l	     equ     $ - cmd_exit
Turbo Assembler	 Version 4.1	    02/21/22 02:35:39	    Page 3
shell.asm



    115
    116				     ; My command line prompt
    117	018F  74 69 6E 79 73 68	65+  prompt_start    db	     'tinyshell:'
    118	      6C 6C 3A
    119	0199  53 3A		     drive_letter    db	     "S", ":"		     ; Current drive buffer
    120	019B  40*(??)		     pwd_buffer	     db	     64	dup (?)		     ; Current path buffer
    121	      =004C		     prompt_l	     equ     $-prompt_start
    122
    123	01DB  5A 3A 2F 43 4F 4D	4D+  command_com     db	     "Z:/COMMAND.COM", 0     ; child program that will be executed (in	    +
    124	      41 4E 44 2E 43 4F	4D+  ASCIIZ-string format)
    125	      00
    126
    127	01EA  0000		     EPB	     dw	     0000		     ; Segment of environment for child		    +
    128				     (0000=current environment)
    129	01EC  01F8r 0000			     dw	     offset commandline, 0   ; Address of command line text to place
    130	01F0  005C 0000	006C 0000		     dw	     005Ch, 0, 006Ch, 0	     ; 005Ch - address of first	FCB passed from	DOS +
    131				     to	our program
    132										     ; 006Ch - address of second FCB passerd from   +
    133				     DOS to our	program
    134										     ; this unopened FCBs addresses will be copied  +
    135				     to	the childs's PSP
    136
    137				     ; Lstring format string (first byte - Length in bytes)
    138	01F8  7D		     commandline     db	     125		     ; Max length of command line
    139	01F9  20 2F 43 20			     db	     " /C "		     ; Text to be passed to the	child program
    140										     ; It will be copied to the	child's	PSP at	    +
    141				     offset 80h
    142
    143	01FD  7A*(??)		     command_text    db	     122 dup (?)	     ; Inputed command
    144	0277  7A		     command_buffer  db	     122		     ; Maximum acceptable input	(in bytes)
    145
    146	      =01F4		     length_of_program	     equ     $ - _start	+ 124
    147
    148				     end _start
Turbo Assembler	 Version 4.1	    02/21/22 02:35:39	    Page 4
Symbol Table




Symbol Name			  Type	 Value

??DATE				  Text	 "02/21/22"
??FILENAME			  Text	 "shell	  "
??TIME				  Text	 "02:35:38"
??VERSION			  Number 040A
@32BIT				  Text	 0
@CODE				  Text	 DGROUP
@CODESIZE			  Text	 0
@CPU				  Text	 0103H
@CURSEG				  Text	 _TEXT
@DATA				  Text	 DGROUP
@DATASIZE			  Text	 0
@FILENAME			  Text	 SHELL
@INTERFACE			  Text	 000H
@MODEL				  Text	 1
@STACK				  Text	 DGROUP
@WORDSIZE			  Text	 2
CMD_EXIT			  Byte	 DGROUP:018A
CMD_EXIT_L			  Number 0005
COMMANDLINE			  Byte	 DGROUP:01F8
COMMAND_BUFFER			  Byte	 DGROUP:0277
COMMAND_COM			  Byte	 DGROUP:01DB
COMMAND_TEXT			  Byte	 DGROUP:01FD
DRIVE_LETTER			  Byte	 DGROUP:0199
EPB				  Word	 DGROUP:01EA
GOT_EXIT			  Near	 DGROUP:0188
LENGTH_OF_PROGRAM		  Number 01F4
MAIN_LOOP			  Near	 DGROUP:0116
PROMPT_END			  Number 0024
PROMPT_L			  Number 004C
PROMPT_START			  Byte	 DGROUP:018F
PWD_BUFFER			  Byte	 DGROUP:019B
STACK_SHIFT			  Number 04F4
_START				  Near	 DGROUP:0100

Groups & Segments		  Bit Size Align  Combine Class

DGROUP				  Group
  _DATA				  16  0000 Word	  Public  DATA
  _TEXT				  16  0278 Word	  Public  CODE
